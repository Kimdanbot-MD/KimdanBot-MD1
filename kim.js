// C√≥digo desde cero por: https://github.com/ferhacks y comentario hecho por: 
// @Kimdanbot-MD     
// @elrebelde21

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé IMPORTACIONES „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê 
const baileys = require('@whiskeysockets/baileys'); // trabajar a trav√©s de descargas por Whatsapp 
const { WaMessageStubType, areJidsSameUser, downloadContentFromMessage, generateWAMessageContent, generateWAMessageFromContent, generateWAMessage, prepareWAMessageMedia, relayMessage} = require('@whiskeysockets/baileys'); // Importa los objetos 'makeWASocket' y 'proto' desde el m√≥dulo '@whiskeysockets/baileys'  
const { default: makeWASocket, proto } = require("@whiskeysockets/baileys") 
const moment = require('moment-timezone') // Trabajar con fechas y horas en diferentes zonas horarias
const gradient = require('gradient-string') // Aplicar gradientes de color al texto   
const { exec, spawn, execSync } =  require("child_process")// Funci√≥n 'execSync' del m√≥dulo 'child_process' para ejecutar comandos en el sistema operativo 
const chalk = require('chalk') // Estilizar el texto en la consola  
const os = require('os') // Proporciona informaci√≥n del sistema operativo 
const fs = require('fs') // Trabajar con el sistema de archivos   
const fetch = require('node-fetch')
const axios = require('axios') 
const cheerio = require('cheerio')
const gpt = require('api-dylux')
const util = require('util')
const createHash = require('crypto') 
const mimetype = require("mime-types")  
const ws = require('ws')
const JavaScriptObfuscator = require('javascript-obfuscator')
const webp = require("node-webpmux")
const Jimp = require('jimp')
const { File } = require("megajs")
const speed = require("performance-now")
const ffmpeg = require("fluent-ffmpeg")
const similarity = require('similarity') 
const translate = require('@vitalets/google-translate-api') 

const color = (text, color) => { // Funci√≥n 'color' que toma un texto y un color como par√°metros
return !color ? chalk.cyanBright(text) : color.startsWith('#') ? chalk.hex(color)(text) : chalk.keyword(color)(text)} // Si no hay color, utilizar el color celeste brillante (por defecto)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé LIBS „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const scp1 = require('./libs/scraper') 
const { TelegraPh, UploadFileUgu, webp2mp4File, floNime } = require('./libs/uploader.js')
const { toAudio, toPTT, toVideo } = require('./libs/convertir.js') 
const { canLevelUp, xpRange } = require('./libs/levelling.js')
const { smsg, fetchBuffer, getBuffer, buffergif, getGroupAdmins, formatp, tanggal, formatDate, getTime, isUrl, sleep, clockString, runtime, fetchJson, jsonformat, delay, format, logic, generateProfilePicture, parseMention, getRandom, msToTime, downloadMediaMessage, convertirMsADiasHorasMinutosSegundos} = require('./libs/fuctions')
const { ytmp4, ytmp3, ytplay, ytplayvid } = require('./libs/youtube') 
const { mediafireDl } = require('./libs/mediafire.js') 

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé C√ìDIGO „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const { jadibot, listJadibot, killJadibot} = require('./serbot.js')
//const { jadibot2} = require('./serbot2.js')
const { Info, ping, col, col1, grupo, estado, dona, cuentas, infobot, listag} = require('./kim/Info')
const { menu, menu1} = require('./kim/Menu')
const {grup, del, setpp, hide, setna, setde, add, k, p, d, link, ban, tag, adm, infogr, warn1, warn2, online, listw} = require('./kim/grupos.js')
const {rob, bal, reg, reg1, reg2, work, mine, buy, claim, perfil, nivel, cofre, lb} = require('./kim/rpg.js') 
const {buscadores} = require('./kim/Busquedas.js')
const {efec, url, tomp3, toimg, toanime} = require('./kim/convertidores.js') 
const {play, play2, play3, play4, mp3, mp4, git, tiktok, letra, mediafire, fb, ig, ig2, apk, spoti} = require('./kim/descargas.js')   
const {game, game1, game2, game3, game4, game5, game6, game7, game8, game9, game10, game11, game12, game13, game14, game15, game16} = require('./kim/juegos.js')  
const {sticker, wm2, attp, dado} = require('./kim/stickers.js')

const msgs = (message) => { // Funci√≥n 'msgs' que toma un par√°metro 'message'
if (message.length >= 10) { // Longitud de 'message' es mayor o igual a 10 caracteres
return `${message.substr(0, 500)}` // Devuelve los primeros 500 caracteres de 'message'
} else { // Caso contrario
return `${message}`}} // Devuelve 'message' completo

const getCmd = (id) => { //Funci√≥n llamada 'getCmd' que toma un par√°metro 'id'
const stickerdb = JSON.parse(fs.readFileSync('./database/stickerdb.json'))
let anu = null;
Object.keys(stickerdb).forEach(nganu => { // Itera sobre las claves del objeto 'stickerdb' utilizando 'forEach'
if (stickerdb[nganu].id === id) { // Si el valor de la propiedad 'id' en el objeto 'stickerdb[nganu]' es igual a 'id'
anu = nganu
}})
if (anu !== null) { // De lo contrario
return stickerdb[anu].cmd // Devolver el valor de la propiedad 'cmd' en el objeto 'stickerdb[anu]'
}}
const getFileBuffer = async (mediakey, MediaType) => {
const stream = await downloadContentFromMessage(mediakey, MediaType)
let buffer = Buffer.from([])
for await(const chunk of stream) {
buffer = Buffer.concat([buffer, chunk]) }
return buffer}

module.exports = conn = async (conn, m, chatUpdate, mek, store, sock) => { // Ra√≠z "conn" para mensajes y argumentos
var body = (m.mtype === 'conversation') ? m.message.conversation : (m.mtype == 'imageMessage' && m.message.imageMessage.caption) ? m.message.imageMessage.caption : (m.mtype == 'videoMessage' && m.message.videoMessage.caption ) ? m.message.videoMessage.caption : (m.mtype == 'extendedTextMessage') ? m.message.extendedTextMessage.text : (m.mtype == 'buttonsResponseMessage') ? m.message.buttonsResponseMessage.selectedButtonId : (m.mtype == 'listResponseMessage') ? m.message.listResponseMessage.singleSelectReply.selectedRowId : (m.mtype == 'templateButtonReplyMessage') ? m.message.templateButtonReplyMessage.selectedId : (m.mtype === 'messageContextInfo') ? m.message.listResponseMessage.singleSelectReply.selectedRowId :  (m.mtype == 'stickerMessage') && (getCmd(m.message.stickerMessage.fileSha256.toString()) !== null && getCmd(m.message.stickerMessage.fileSha256.toString()) !== undefined) ? getCmd(m.message.stickerMessage.fileSha256.toString()) : ''
	
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé ATRIBUTOS „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (m.key.id.startsWith("BAE5")) return
var budy = (typeof m.text == 'string' ? m.text : '') // Asignar a la variable budy el valor m.text si es cadena	
//var prefix = prefa ? /^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=/|~!?@#$%^&.¬©^]/gi.test(body) ? body.match(/^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=/|~!?@#$%^&.¬©^]/gi)[0] : "" : prefa ?? global.prefix = new RegExp('^[¬∞‚Ä¢œÄ√∑√ó¬∂‚àÜ¬£¬¢‚Ç¨¬•¬Æ‚Ñ¢+‚úì_=/|~!?@#$%^&.¬©^' + '*/!#$%+¬£¬¢‚Ç¨¬•^¬∞=¬∂‚àÜ√ó√∑œÄ‚àö‚úì¬©¬Æ:;?&.\\-.@'.replace(/[|\\{}()[\]^$+*?.\-\^]/g, '\\$&') + ']', 'i')
global.prefix = body.match(/^[/.*#]/)  
const prefix = global.prefix
const isCmd = body.startsWith(prefix) // Verificar si el contenido de body comienza con el valor almacenado en prefix.
const from = m.chat // Remitente del mensaje
const msg = JSON.parse(JSON.stringify(mek, undefined, 2)) // Mensaje convertido a formato JSON
const content = JSON.stringify(m.message) // Contenido del mensaje convertido a formato JSON
const type = m.mtype // Tipo de mensaje
const arg = body.substring(body.indexOf(' ') + 1) // Argumento extra√≠do del cuerpo del mensaje
const command = body.replace(prefix, '').trim().split(/ +/).shift().toLowerCase() // Comando extra√≠do del cuerpo del mensaje
const args = body.trim().split(/ +/).slice(1) // Obtiene los argumentos del comando
const full_args = body.replace(command, '').slice(1).trim()
const q = args.join(" ") // Une los argumentos en una sola cadena separada por espacios
let t = m.messageTimestamp // Marca de tiempo de mensaje
const pushname = m.pushName || "Sin nombre" // Obtiene el nombre de visualizaci√≥n del usuario de lo contrario ser√° "Sin nombre"
const botnm = conn.user.id.split(":")[0] + "@s.whatsapp.net"
const userSender = m.key.fromMe ? botnm : m.isGroup && m.key.participant.includes(":") ? m.key.participant.split(":")[0] + "@s.whatsapp.net" : m.key.remoteJid.includes(":") ? m.key.remoteJid.split(":")[0] + "@s.whatsapp.net" : m.key.fromMe ? botnm : m.isGroup ? m.key.participant : m.key.remoteJid
const isCreator = global.owner.map(([numero]) => numero.replace(/[^\d\s().+:]/g, '').replace(/\s/g, '') + '@s.whatsapp.net').includes(userSender) // Eliminar todo a excepci√≥n de n√∫meros
const isOwner = isCreator || m.fromMe;
const itsMe = m.sender == conn.user.id ? true : false // Verifica si el remitente del mensaje es el propio bot	
const text = args.join(" ") // Unir rgumentos en una sola cadena separada por espacios
const quoted = m.quoted ? m.quoted : m // Obtiene el mensaje citado si existe, de lo contrario, se establece como el propio mensaje
const sender = m.key.fromMe ? botnm : m.isGroup ? m.key.participant : m.key.remoteJid // Obtiene el remitente del mensaje seg√∫n el tipo de chat (individual o grupo)
const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms))	
const mime = (quoted.msg || quoted).mimetype || '' // Tipo de archivo adjunto del mensaje citado o del propio mensaje
const qmsg = (quoted.msg || quoted)	
const isMedia = /image|video|sticker|audio/.test(mime) // Verifica si el mensaje contiene un archivo multimedia (imagen, video, sticker o audio)
const numBot = conn.user.id.split(":")[0] + "@s.whatsapp.net" // JID del Bot
const numBot2 = conn.user.id // N√∫mero de tel√©fono del bot
const mentions = []
if (m.message[type].contextInfo) { 
if (m.message[type].contextInfo.mentionedJid) {
const msd = m.message[type].contextInfo.mentionedJid
for (let i = 0; i < msd.length; i++) {
mentions.push(msd[i])}}}
	
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé GRUPO „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const groupMetadata = m.isGroup ? await conn.groupMetadata(from) : '' // Obtiene informaci√≥n del grupo
const groupName = m.isGroup ? groupMetadata.subject : '' // Nombre del grupo
const participants = m.isGroup ? await groupMetadata.participants : '' // Lista de participantes del grupo
const groupAdmins = m.isGroup ? await getGroupAdmins(participants) : '' // // Lista de administradores del grupo
const isBotAdmins = m.isGroup ? groupAdmins.includes(numBot) : false // Verifica si el bot es un administrador del grupo
const isGroupAdmins = m.isGroup ? groupAdmins.includes(userSender) : false // Verifica si el remitente del mensaje es un administrador del grupo
const isBaneed = m.isGroup ? blockList.includes(userSender) : false // Verifica si el remitente del mensaje est√° en la lista de bloqueados
const isPremium = m.isGroup ? premium.includes(userSender) : false 
const who = m.quoted ? m.quoted.sender : m.mentionedJid && m.mentionedJid[0] ? m.mentionedJid[0] : m.fromMe ? conn.user.jid : m.sender;
const thumb = fs.readFileSync("./src/test.jpg")
const fkontak = { "key": { "participants":"0@s.whatsapp.net", "remoteJid": "status@broadcast", "fromMe": false, "id": "Halo" }, "message": { "contactMessage": { "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:Sy;Bot;;;\nFN:y\nitem1.TEL;waid=${userSender.split('@')[0]}:${userSender.split('@')[0]}\nitem1.X-ABLabel:Ponsel\nEND:VCARD` }}, "participant": "0@s.whatsapp.net" }
const ftroli ={key: {fromMe: false,"participant":"0@s.whatsapp.net", "remoteJid": "status@broadcast"}, "message": {orderMessage: {itemCount: 2022,status: 200, thumbnail: thumb, surface: 200, message: "…¥·¥è·¥†·¥Ä ô·¥è·¥õ-·¥ç·¥Ö", orderTitle: "s·¥ú·¥ò·¥á Ä  ô·¥è·¥õ ·¥Ö·¥á ·¥° ú·¥Ä·¥õs·¥Ä·¥ò·¥ò", sellerJid: '0@s.whatsapp.net'}}, contextInfo: {"forwardingScore":999,"isForwarded":true},sendEphemeral: true}
const fdoc = {key : {participant : '0@s.whatsapp.net', ...(from ? { remoteJid: `status@broadcast` } : {}) },message: {documentMessage: {title: botname, jpegThumbnail: null}}}
const kick = function (from, orangnya) {  
for (let i of orangnya) {  
conn.groupParticipantsUpdate(m.chat, [i], "remove")}}  
const time = moment(Number(msg.messageTimestamp + "000")).locale("es-mx").tz("America/Asuncion").format('MMMM Do YYYY, h:mm:ss a')  

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé MENSAJES „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const reply = (text) => {
m.reply(text)} // Enviar una respuesta
const sendAdMessage = (text, title, body, image, url) => { conn.sendMessage(from, {text: text, contextInfo: { externalAdReply: { title: title, body: body, mediaUrl: url, sourceUrl: url, previewType: 'PHOTO', showAdAttribution: true, thumbnail: image, sourceUrl: url }}}, {})}
const sendImage = ( image, caption ) => { conn.sendMessage(from, { image: image, caption: caption }, { quoted: m })}
const sendImageAsUrl = ( url, caption ) => { conn.sendMessage(from, { image:  {url: url }, caption: caption }, { quoted: m })}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé TIPOS DE MENSAJES Y CITADOS „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const isAudio = type == 'audioMessage' // Mensaje de Audio
const isSticker = type == 'stickerMessage' // Mensaje de Sticker
const isContact = type == 'contactMessage' // Mensaje de Contacto
const isLocation = type == 'locationMessage' // Mensaje de Localizaci√≥n 
const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')
const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')
const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')
const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')
const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')
const isQuotedMsg = type === 'extendedTextMessage' && content.includes('Message') // Mensaje citado de cualquier tipo
const isViewOnce = (type === 'viewOnceMessage') // Verifica si el tipo de mensaje es (mensaje de vista √∫nica)

if (isMedia && m.msg.fileSha256 && (m.msg.fileSha256.toString('base64') in global.db.data.sticker)) {
let hash = global.db.data.sticker[m.msg.fileSha256.toString('base64')]
let { text, mentionedJid } = hash
let messages = await generateWAMessage(m.chat, { text: text, mentions: mentionedJid }, {userJid: conn.user.id,
quoted: m.quoted && m.quoted.fakeObj
})
messages.key.fromMe = areJidsSameUser(m.sender, conn.user.id)
messages.key.id = m.key.id
messages.pushName = m.pushName
if (m.isGroup) messages.participant = m.sender
let msg = {...chatUpdate, messages: [proto.WebMessageInfo.fromObject(messages)],
type: 'append'
}
conn.ev.emit('messages.upsert', msg)}

//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé AUTOREAD „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (!conn.autoread && m.message && prefix) {
await conn.sendPresenceUpdate('composing', m.chat)
conn.readMessages([m.key])}

//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé ANTISPAM „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].antispam && prefix) {
const date = global.db.data.users[m.sender].spam + 3000; //5 seg
if (new Date - global.db.data.users[m.sender].spam < 3000) return //conn.sendMessage(m.chat, {text: `_*Espere unos segundos antes de usar otro comando...*_ ‚úì`, mentions: [sender], },{quoted: m}) 
global.db.data.users[m.sender].spam = new Date * 1
}
            
//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé ANTIFAKE „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].antifake && !isGroupAdmins) {	
let forbidPrefixes = ["1", "994", "48", "43", "40", "41", "49"];
for (let prefix of forbidPrefixes) {
if (m.sender.startsWith(prefix)) {
m.reply(`${lenguaje.smsAntiFake}`, m.sender)
conn.groupParticipantsUpdate(m.chat, [m.sender], 'remove')}}}
if (global.db.data.chats[m.chat].antiarabe && !isGroupAdmins) {
let forbidPrefixes = ["212", "265", "234", "258", "263", "967", "20", "92", "91"];
//if (m.chat && m.sender.startsWith('212')) return
for (let prefix of forbidPrefixes) {
if (m.sender.startsWith(prefix)) {
m.reply(`${lenguaje.smsAntiArabe}`, m.sender)
conn.groupParticipantsUpdate(m.chat, [m.sender], 'remove')}}}
	
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé AUTOBIO „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê	
    const sk = [
      "ùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùêåùêÉüå∫üçì",
      "ùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùêåùêÉü´êüå∏",
      "ùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùêåùêÉüçíüçá",
      "ùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùêåùêÉüç®üç¨",
    ];
    const XD = sk[Math.floor(Math.random() * sk.length)];

if (db.data.settings[numBot].autobio) { 
 let setting = global.db.data.settings[numBot] 
 if (new Date() * 1 - setting.status > 1000) { 
 //let uptime = await runtime(process.uptime()) 
 const bio = `${XD}\n${runtime(process.uptime())}` 
 await conn.updateProfileStatus(bio) 
 setting.status = new Date() * 1 
 }}
	
//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé ANTILINK „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (db.data.chats[m.chat].antilink) {
if (budy.match(`chat.whatsapp.com`)) {
let delet = m.key.participant
let bang = m.key.id
let user = m.sender	
if (!isBotAdmins) return reply(`ùöéùöï ùöãùöòùöù ùöóùöéùöåùöéùöúùöíùöùùöä ùöúùöéùöõ ùöäùöçùöñùöíùöó`)
if (isGroupAdmins) return reply(`no ser√°s eliminado ya que eres admin`)
let gclink = (`https://chat.whatsapp.com/`+await conn.groupInviteCode(m.chat))
let isLinkThisGc = new RegExp(gclink, 'i')
let isgclink = isLinkThisGc.test(m.text)
if (isgclink) return reply(`el link es de este grupo, no ser√°s eliminado`)
conn.sendMessage(m.chat, { delete: { remoteJid: m.chat, fromMe: false, id: bang, participant: delet }})
conn.sendMessage(m.chat, {text: `*„Äå ANTI LINK „Äç*\n\n*ùöïùöíùöóùöî ùöçùöéùöùùöéùöåùöùùöäùöçùöò*`})
conn.groupParticipantsUpdate(m.chat, [m.sender], 'remove')}}

//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé PUBLIC Y PRIVADO „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (!conn.public && !isCreator) {
if (!m.key.fromMe) return
}        	
//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé BANCHAT „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].isBanned) {
return
}
//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé MODO ADMIN „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].modeadmin && !isGroupAdmins) {
return
}
	
  //‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé AUTOSTICKER„Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].autosticker) {  
if (/image/.test(mime)) {  
await conn.sendPresenceUpdate('composing', m.chat)
m.reply(`${lenguaje.smsAutoSicker.espera}`)   
media = await quoted.download()  
let encmedia = await conn.sendImageAsSticker(m.chat, media, m, { packname: global.packname, author: global.author, contextInfo: { 'forwardingScore': 200, 'isForwarded': false, externalAdReply:{ showAdAttribution: false, title: botname, body: `h`, mediaType: 2, sourceUrl: nn6, thumbnail: imagen1}}}, { quoted: m })
await fs.unlinkSync(encmedia)   
} else if (/video/.test(mime)) {  
if ((quoted.msg || quoted).seconds > 40) return reply(`${lenguaje.smsAutoSicker.tiempo}`)  
media = await quoted.download()  
let encmedia = await conn.sendVideoAsSticker(m.chat, media, m, { packname: global.packname, author: goblal.author, contextInfo: { 'forwardingScore': 200, 'isForwarded': false, externalAdReply:{ showAdAttribution: false, title: wm, body: `h`, mediaType: 2, sourceUrl: nn6, thumbnail: imagen1}}}, { quoted: m })
await new Promise((resolve) => setTimeout(resolve, 2000));   
await fs.unlinkSync(encmedia)  
}}

//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé AUTOLEVELUP „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.users[m.sender].autolevelup) {	
let user = global.db.data.users[m.sender]
const date = moment.tz('America/Bogota').format('DD/MM/YYYY')
const time = moment.tz('America/Bogota').format('LT')
if (!user.autolevelup)
return !0
let before = user.level * 1
while (canLevelUp(user.level, user.exp, global.multiplier))
user.level++
//user.role = global.rpg.role(user.level).name
if (before !== user.level) {
var x = before;
var y = user.level;
let z = (x -- y);
const str = `${lenguaje['smsAutonivel']()} @${sender.split`@`[0]} ${lenguaje['smsAutonivel2']()} ${before}\n${lenguaje['smsAutonivel3']()} ${user.level}\n${lenguaje['smsAutonivel5']()} ${z}\n${lenguaje['smsAutonivel6']()} ${user.role}\n${lenguaje['smsAutonivel7']()} ${date}\n${lenguaje['smsAutonivel8']()} ${time}\n${lenguaje['smsAutonivel9']()}`.trim()
return conn.sendMessage(m.chat, { text: str, contextInfo:{mentionedJid:[sender]}}, { quoted: fkontak })}}

//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé CHATBOT „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].simi) {
let textodem = budy
try {
await conn.sendPresenceUpdate('composing', m.chat)
const ressimi = await fetch(`https://api.simsimi.net/v2/?text=${encodeURIComponent(textodem)}&lc=es`)
const data = await ressimi.json()
if (data.success == 'No s\u00e9 lo qu\u00e9 est\u00e1s diciendo. Por favor ense\u00f1ame.') return m.reply(`${lol}`);
await m.reply(data.success)
} catch {
if (textodem.includes('Hola','ùêáùê®ùê•ùêö','“ª·•Ü·•£·•≤')) textodem = textodem.replace('ùêáùê®ùê•ùêö', 'ùêáùêûùê•ùê•ùê®')
if (textodem.includes('hola','ùê°ùê®ùê•ùêö','“ª·•Ü·•£·•≤')) textodem = textodem.replace('ùê°ùê®ùê•ùêö', 'ùê°ùêûùê•ùê•ùê®')
if (textodem.includes('HOLA','ùêáùêéùêãùêÄ','“ª·•Ü·•£·•≤')) textodem = textodem.replace('ùêáùêéùêãùêÄ', 'ùêáùêÑùêãùêãùêé')
const reis = await fetch('https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=en&dt=t&q=' + textodem)
const resu = await reis.json()
const nama = m.pushName || '1'
const api = await fetch('http://api.brainshop.ai/get?bid=153868&key=rcKonOgrUFmn5usX&uid=' + nama + '&msg=' + resu[0][0][0])
const res = await api.json()
const reis2 = await fetch('https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=es&dt=t&q=' + res.cnt)
const resu2 = await reis2.json()
await m.reply(resu2[0][0][0])}}
	
//‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé ANTIPRIV „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (global.db.data.chats[m.chat].antiprivado && !isCreator) {
if (m.isBaileys && m.fromMe) return !0;
if (m.isGroup) return !0;
if (!m.message) return !1;
if (budy.includes('menu') || budy.includes('estado') || budy.includes('bots') ||  budy.includes('serbot') || budy.includes('jadibot')) return !1
const chat = global.db.data.chats[m.chat];
const bot = global.db.data.settings[numBot]
await conn.sendMessage(m.chat, {text: `${lenguaje.smsAntiPv}\n${nn2}`, mentions: [sender], },{quoted: m})
await conn.updateBlockStatus(m.chat, 'block')
return !1;
}

let mentionUser = [...new Set([...(m.mentionedJid || []), ...(m.quoted ? [m.quoted.sender] : [])])]
for (let jid of mentionUser) {
let user = global.db.data.users[jid]
if (!user) continue
let afkTime = user.afkTime
if (!afkTime || afkTime < 0) continue
let reason = user.afkReason || ''
m.reply(`[ üí§ ùôΩùôæ ùôªùôæùöÇ ùô¥ùöÉùô∏ùöÄùöÑùô¥ùöÉùô¥ üí§ ]\n\nùô¥ùöúùöùùöé ùöûùöúùöûùöäùöõùöíùöò ùööùöûùöé ùöñùöéùöóùöåùöíùöòùöóùöäùöú ùöéùöúùöùùöä ùô∞ùôµùô∫\n\n${reason ? 'üî∏Ô∏è *ùöÅùô∞ùöâùôæùôΩ* : ' + reason : 'üî∏Ô∏è *ùöÅùô∞ùöâùôæùôΩ* : ùöÇùöíùöó ùöõùöäùö£ùöòùöó'}\nüî∏Ô∏è *ùô¥ùöÇùöÉùöÑùöÖùôæ ùô∏ùôΩùô∞ùô≤ùöÉùô∏ùöÖùôæ ùô≥ùöÑùöÅùô∞ùôΩùöÉùô¥ : ${clockString(new Date - afkTime)}`.trim())}
if (global.db.data.users[m.sender].afkTime > -1) {
let user = global.db.data.users[m.sender]
m.reply(`*üïî ùô≥ùô¥ùôπùô∞ùöÇùöÉùô¥ ùô≥ùô¥ ùô¥ùöÇùöÉùô∞ ùô∞ùôµùô∫ üïî*\n${user.afkReason ? '\n*ùöÅùô∞ùöâùôæùôΩ :* ' + user.afkReason : ''}\n*ùô¥ùöÇùöÉùöÑùöÖùôæ ùô∏ùôΩùô∞ùô≤ùöÉùô∏ùöÖùôæ ùô≥ùöÑùöÅùô∞ùôΩùöÉùô¥ :* ${clockString(new Date - user.afkTime)}`.trim())
user.afkTime = -1
user.afkReason = ''
}    
	
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé CONSOLA „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê	
if (m.message) {
console.log(chalk.bold.magenta(' ‡º∫  üçì  ùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùêåùêÉ üçì ‡ºª'), 
chalk.bold.cyanBright(`\n‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÖ‚îÖ\n‚îÉüè∑Ô∏è  +${conn.user.id.split("@")[0]}`), 
chalk.bold.yellow(`${lenguaje.Bio.fecha}`) + chalk.yellow(moment(t * 1000).tz(place).format('DD/MM/YY'),	
chalk.bold.red(`${lenguaje.Bio.hora}`) + chalk.red(moment(t * 1000).tz(place).format('HH:mm:ss'),
chalk.bold.magenta(`${lenguaje.Bio.usuario}`) + chalk.magenta(pushname) + '  ‚ûú ', gradient.rainbow(userSender), 
m.isGroup ? chalk.bold.yellow(`${lenguaje.Bio.grupo}`) + chalk.yellow(groupName) + '  ‚ù• ': chalk.bold.yellow(`${lenguaje.Bio.priv}`), 
chalk.bold.cyanBright('\n‚îÉ') + chalk.bold.white(`${lenguaje.Bio.mensaje}${msgs(m.text)}`) + chalk.bold.cyanBright(`\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÖ‚îÖ\n`)
)))}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé MULTILENGUAJE „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê	
const { en, es } = require('./libs/idiomas/total-idiomas.js')
let user = global.db.data.users[m.sender]
if (user.Language == 'es') {
global.lenguaje = es
} else if (user.Language == 'en') {
global.lenguaje = en
} else {
global.lenguaje = es
}   	

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêìäà„Äé AUTOMATIC „Äèìäâ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê	
let mensaje
if (mensaje) {  
if (m.isGroup) return !1;
if (!m.message) return !0;
let str = [nna, md, yt, tiktok, fb] 
let info = str[Math.floor(Math.random() * str.length)]
let totalreg = Object.keys(global.db.data.users).length
let rtotalreg = Object.values(global.db.data.users).filter(user => user.registered == true).length
conn.sendMessage(m.chat, { text: `*Hola @${sender.split`@`[0]} üëãüòÑ Mi nombre es ${botname} Soy un bot de WhatsApp con multi funcione üëæ, registrarte para poder usar mi comando üëå*\n\n*üí´ MI INFO:*\n*üëë Mi creador es:* wa.me/5492266466080\n*üë• Usuarios:* ${totalreg}\n*‚ú® Registrado:* ${rtotalreg}\n*ü§ñ Estoy activa desde:* ${runtime(process.uptime())}\n*‚ö†Ô∏è PD:* No hagan spam del comando o te van baneado\n\n‚Ä¢ *PORFAVOR LEE LAS REGLAS:*\n#reglas\n\n‚Ä¢ *QUIERES VER QUE HAY DE NUEVO?*\n*Escribe:* #nuevo\n\n‚Ä¢ *¬øQUIERE SOLICITA UN BOT PARA TU GRUPO?*\n*Escribe:* #solicitud\n\n*üí´ ¬øQuieres apoyar este proyecto para que siga actualiz√°ndose?*\n‚Ä¢ #donar\n\n*‚ú® CUENTA OFICIALES*\n‚Ä¢ #cuentas`, contextInfo:{mentionedJid:[sender], forwardingScore: 9999999, isForwarded: true, "externalAdReply": {"showAdAttribution": true, "containsAutoReply": true, "title": wm, thumbnail: imagen2, sourceUrl: info}}}, { quoted: fkontak, ephemeralExpiration: 24*60*100, disappearingMessagesInChat: 24*60*100})							  
mensaje = true
return !1;
}
	
switch (command) {
case 'priv': {
if (!isCreator) return m.reply(mess.owner)
if (!text) return m.reply(`y el texto`)
if (args[0] === "on") {
global.db.data.chats[m.chat].antiprivado = true
m.reply(`‚úÖ activado`)
} else if (args[0] === "off") {
global.db.data.chats[m.chat].antiprivado = false
m.reply(`üü¢ desactivado`)}}
break		
//idiomas 
case 'idioma': case 'Language': case 'idiomas': { 
let user = global.db.data.users[m.sender]
if (!text) return m.reply(`a que idioma cambio?`) 
if (budy.includes(`1`)) { 
idioma = 'es' 
idiomas = 'espa√±ol'
}
if (budy.includes(`2`)) {
idioma = 'en'
idiomas = 'ingles'
}
user.Language = idioma
m.reply(`se cambio a ` + idiomas)}  
break 
		
	/*case 'imagen':
let pp = await conn.profilePictureUrl(m.chat, 'image')	
await conn.sendMessage(m.chat, pp) 		
	break
case 'serbot': case 'qr':
jadibot(conn, m, command)  
break  
//case 'jadibot': case 'sercode':
//jadibot2(conn, m, command, text, args, sender)
//break		
case 'deljadibot': case 'stop': 
killJadibot(conn, m, prefix, command)
break 
case 'bots': case 'listbots': 
const user = [...new Set([...global.listJadibot.filter((conn) => conn.user && conn.ws.socket && conn.ws.socket.readyState !== ws.CLOSED).map((conn) => conn)])];
const message = user.map((v, index) => `[${index + 1}] ${v.user.name || '‚Ä¢'}\nwa.me/${v.user.jid.replace(/[^0-9]/g, '')}?text=${prefix}estado`).join('\n\n');
const replyMessage = message.length === 0 ? '' : message;
const totalUsers = user.length;
const responseMessage = `*ùòöùòúùòâùòâùòñùòõùòö ùòäùòñùòïùòåùòäùòõùòàùòãùòñùòö:* ${totalUsers || '0'}\n\n${replyMessage.trim()}`.trim();
await conn.sendMessage(m.chat, {text: responseMessage, mentions: conn.parseMention(responseMessage)}, {quoted: m});
break*/ 
		
// ùêàùêçùêÖùêéùêëùêåùêÄùêÇùêàùêéùêç ùêÉùêÑ ùêäùêàùêåùêÉùêÄùêçùêÅùêéùêì-ùêåùêÉ
case 'estado': case 'heydan': case 'status':
await estado(conn, imgkim, sendImage, from, m) 
break		
case 'ping':  
var timestamp = speed();  
var latensi = speed() - timestamp  
conn.sendMessage(from, { text: `*ùêèùê®ùêßùê† üèì  ${latensi.toFixed(4)}*\n${s}` }, { quoted: msg });  					
case 'velocidad':
await ping(conn, imagen3, sendImage, from, m)
break;		
case 'infokim': case 'infobot': 
await infobot(conn, imagen2, sendImage, from, m) 
break		
case 'creador': 
await Info(conn, m, from, sendImage)
break
case 'colaboradores': 
await col(conn, m, from, sender, fs, sendImage)
break
case 'Colaborador1': case 'colab1': 
await col1(conn, m, from)
break      
case 'gruposkim': case 'grupos': case 'groupkim': 
await grupo(conn, m, from)
break		
case 'donacion': case 'donate': case 'donar':
await dona(conn, m, from, sendImage)
break
case 'cuentaskim': case 'cuentaskimbot': case 'cuentas': 
await cuentas(conn, m, from)
break
case 'listagrupos': case 'grouplist': case 'listagru': 
await listag(conn, m, from)
break 
case 'menu': 
await menu(conn, m, from)
break 		
case 'menu1': 
await menu1(conn, m, from, fs.readFileSync('./src/img_cuadrada.jpg'));
break
case 'report': case 'reportar': {
if (!text) return m.reply(`üå∏ *ùêàùêçùêÜùêëùêÑùêíùêÄ ùêÑùêã ùêÇùêéùêåùêÄùêçùêÉùêé ùêÇùêéùêç ùêÖùêÄùêãùêãùêÄ*\n‚ùñ‚Éü›äüçí‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n „Äêüå∫„ÄëùêÑùê£ùêûùê¶ùê©ùê•ùê®: ${prefix + command} ùê¨ùê≠ùê¢ùêúùê§ùêûùê´ ùêßùê® ùêüùêÆùêßùêúùêö\n‚ùñ‚Éü›äü´ê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`)
conn.sendMessage("120363161344146891@g.us", {text: `‚îè‚îÅ‚îÅ„Äé *üå∫ ùêë ùêÑ ùêè ùêé ùêë ùêì ùêÑ üå∫* „Äè‚îÅ‚îÅ ‚úø\n‚îÉ\n‚îÉ *ñ°π ùêç ùêî ùêå ùêÑ ùêë ùêé:* üçí\n‚îÉ *‚û•*  wa.me/${m.sender.split("@")[0]}\n‚îÉ\n‚îÉ *ñ°π ùêå ùêÑ ùêç ùêí ùêÄ ùêâ ùêÑ:* ü´ê\n‚îÉ *‚û•* ${text}\n‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ„Äé *${vs}* „Äè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚úø`})
m.reply(`li.‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞.li\n*üçìÍô∞·∑ú‡∑ñ‡∑èùÜ∫‚ñ∏ ùêÑÃÅùêóùêàùêìùêé*\n*‚ï∞‚ù•* ùêÑùê• ùê´ùêûùê©ùê®ùê´ùê≠ùêû ùêüùêÆùêû ùêûùêßùêØùê¢ùêöùêùùê® ùêö ùê¶ùê¢ùê¨ ùê©ùê´ùê®ùê†ùê´ùêöùê¶ùêöùêùùê®ùê´ùêûùê¨, ùê¨ùê¢ ùêûùê¨ ùêßùêûùêúùêûùê¨ùêöùê´ùê¢ùê® ùêßùê®ùê¨ ùêúùê®ùêßùê≠ùêöùêúùê≠ùêöùê´ùêûùê¶ùê®ùê¨ ùêúùê®ùêß ùêÆùê¨ùê≠ùêûùêù, ùêùùêû ùê¨ùêûùê´ ùêüùêöùê•ùê¨ùê®\nùêûùê• ùê´ùêûùê©ùê®ùê´ùê≠ùêû ùê¨ùêûùê´ùêöÃÅ ùê¢ùê†ùêßùê®ùê´ùêöùêùùê® ùê≤ ùêõùê•ùê®ùê™ùêÆùêûùêöùêùùê®(ùêö)\nùêùùêûùê• ùêõùê®ùê≠ ùêîùêßùêî.\nli.‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞.li`) 
}
break 
		
// ùêÅùêîùêíùêêùêîùêÑùêÉùêÄùêí
case 'yts': case 'ytsearch': case 'acortar': case 'google': case 'imagen': case 'traducir': case 'translate': case "tts": case 'ia': case 'chatgpt': case 'dalle': case 'ia2': case 'aimg': case 'imagine': case 'dall-e': case 'ss': case 'ssweb': case 'wallpaper': case 'hd': await buscadores(m, command, conn, text, from, fkontak, prefix, args, quoted, lolkeysapi)
break

// ùêíùêìùêàùêÇùêäùêÑùêëùêí
case 's': case 'sticker':  
sticker(conn, mime, quoted, m) 
break; 
case 'wm': case 'take': 
wm2(conn, args, quoted, mime, m) 
break 
case 'attp': 
attp(conn, text, lolkeysapi, fkontak, m) 
break
case 'dado': 
dado(conn, lolkeysapi, fkontak, m) 
break

//ùêÜùêëùêîùêèùêé 
/*case 'grupo': 
grup(conn, m, args, isBotAdmins, isGroupAdmins, command, prefix, text)
break
case 'delete': case 'del': 
del(conn, m, isBotAdmins, isGroupAdmins)
break  		           
case 'hidetag': case 'notificar': 
hide(conn, m, isBotAdmins, isGroupAdmins, q, participants)
break 
case 'setppname': case 'nuevonombre': case 'newnombre': 
setna(conn, m, isBotAdmins, isGroupAdmins, text)
break
case 'setdesc': case 'descripci√≥n':  
setde(conn, m, isBotAdmins, isGroupAdmins, text)
break
case 'setppgroup': case 'setpp': 
setpp(conn, m, isBotAdmins, isGroupAdmins, quoted, prefix, command, mime, args, from)
break
case 'anularlink': case 'resetlink': case 'revoke':
let res = conn.groupRevokeInvite(m.chat)
break
case 'add': case 'agregar': case 'invitar': 
add(conn, m, isBotAdmins, isGroupAdmins, text, sender, prefix)
break           
case 'kick': case 'echar': case 'sacar':
k(conn, m, isBotAdmins, isGroupAdmins, quoted, text, sender)
break 
case 'promote':
p(conn, m, isBotAdmins, isGroupAdmins, quoted, sender)
break
case 'demote':
d(conn, m, isBotAdmins, isGroupAdmins, quoted, sender)
break */           
case 'link': case 'linkgc': 
link(conn, m, isBotAdmins)
break                        		
/*case 'banchat': 
ban(m, text, command, args)
break              
case 'tagall': case 'invocar': case 'todos':
tag(conn, m, isBotAdmins, isGroupAdmins, participants, q)
break            
case 'admins': case 'administradores': 
adm(conn, participants, groupMetadata, args, m) 
break
case 'infogrupo': case 'groupinfo':
infogr(conn, participants, groupMetadata, fkontak, m) 
break  
case 'warn': case 'advertencia':
warn1(conn, m, isBotAdmins, isGroupAdmins, sender, command, text, delay) 
break 
case 'unwarn': case 'quitardvertencia': 
warn2(conn, m, isBotAdmins, isGroupAdmins, sender, command, delay) 
break
case 'listwarn': 
listw(conn, isCreator, m) 
break
case 'listonline': case 'liston': 
online(conn, sender, args, store, m) 
break */

//ùêëùêèùêÜ
case 'reg': case 'verificar':
await reg(conn, m, sender, text, fkontak, delay)
break            
case 'unreg': 
reg1(args, m, sender)  
break
case 'myns':
reg2(sender, m)
break 
case 'afk': {
if (global.db.data.users[m.sender].registered < true) return m.reply(info.registra)
let user = global.db.data.users[m.sender]
user.afkTime = + new Date
user.afkReason = text
m.reply(`‚ï≠‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚â™ ùô∞ùô∫ùôµ ‚â´‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚ïÆ
‚îÉ ùô¥ùöÇùöÉùô¥ ùöÑùöÇùöÑùô∞ùöÅùô∏ùôæùöÇ ${pushname}
‚îÉ ùô¥ùöÇùöÉùô∞ ùô∏ùôΩùô∞ùô≤ùöÉùô∏ùöÖùôæ üò¥
‚îÉ ‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã‚âã
‚îÉ üí§ ùôΩùôæ ùôªùôæùöÇ ùô¥ùöÉùô∏ùöÄùöÑùô¥ùöÉùô¥ üí§
‚îÉ ‚ò£Ô∏è ùôºùôæùöÉùô∏ùöÖùôæùöÇ : ${text ? text : ''}
‚ï∞‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚â™ ${vs} ‚â´‚îÄ‚îÅ‚îÄ‚îÅ‚îÄ‚îÅ‚ïØ`)}
break             
case 'buy': case 'buyall': {
await buy(conn, m, sender, args, command, text, fkontak)}
break
case 'minar': case 'mine':
await mine(conn, m, sender, fkontak)
break 
case 'trabajar': case 'work': case 'w': {
await work(conn, m, sender, fkontak)}
break
case 'rob': case 'robar': { 
await rob(conn, m, sender, fkontak)}
break
case 'bal': case 'balance': case 'diamond': {
await bal(conn, m, sender, fkontak)}
break
case 'claim': case 'daily': 
await claim(conn, m, sender)
break
case 'perfil':
await perfil(conn, who, sender, pushname, fkontak, m) 
break
case 'levelup': case 'nivel': {  
nivel(conn, sender, canLevelUp, xpRange, m, pushname)}
break  
case 'cofre':
cofre(conn, sender, m) 
break 
case 'lb': case 'leaderboard':
lb(conn, participants, args, m) 
break 
		
//juegos
case 'simi': case 'alexa': case 'siri':
await game(m, text, pushname, command)
break  
case 'gay': 
await game1(conn, m, participants, sender, who)
break            
case 'pareja': case 'formarpareja':
await game2(conn, m, pushname, participants, sender)
break
case 'fake': 
await game3(conn, text, prefix, command, body, from, m, sender, quoted)
break
case 'follar': case 'violar':
game4(conn, m, pushname, text, sender)
break 
case 'ppt': case 'suit':
game5(conn, m, pushname, text, sender)
break
case 'pregunta': case 'preg':
game6(text, command, m)  
break   
case 'doxear': case 'doxxeo': 
game7(conn, pickRandom, text) 
break
case 'personalidad': 
game8(conn, text, pickRandom, m) 
break   
case 'slot':  case 'apuesta':
game9(conn, args, prefix, command, msToTime, m) 
break
case 'verdad':
game10(sendImageAsUrl, pickRandom)   
break   
case 'reto': 
game11(pickRandom, sendImageAsUrl)   
break                
case 'top': 
game12(conn, text, participants, pickRandom, m) 
break 
case 'topgays': case 'topotakus': 
game13(conn, participants, command, m) 
break 
case 'piropo':
game14(m, pickRandom) 
break
case 'racista':
game15(m, body)  
break
case 'love': 
game16(conn, text, m, sender) 
break
//convertidores
case 'bass': case 'blown': case 'deep': case 'earrape': case 'fast': case 'fat': case 'nightcore': case 'reverse': case 'robot': case 'slow': case 'smooth': case 'squirrel': 
efec(conn, command, mime, quoted, exec, prefix, m, from) 
break   
case 'toaudio': case 'tomp3': 
tomp3(conn, mime, quoted, m) 
break
case 'toimg': case 'toimagen':
toimg(conn, mime, quoted, exec, m) 
break
case 'tourl': 
url(conn, mime, quoted, util, m) 
break
case 'toanime': 
toanime(conn, mime, quoted, lolkeysapi, m) 
break

//descargas		    
case 'play': case 'musica': 
play(conn, text, command, m)  
break   
case 'play2': case 'video': 
play2(conn, text, command, args, m)  
break 
case 'play3': case 'playdoc': case 'playaudiodoc': case 'ytmp3doc': 
play3(conn, text, command, args, m)  
break
case 'play4': case 'playdoc2': case 'playvideodoc': case 'ytmp4doc': 
play4(conn, text, command, args, m)   
break
case "ytmp3": case "ytaudio": 
mp3(conn, args, text, command, fkontak, ytplayvid, m)
break 
case 'ytmp4': case 'ytvideo': 
mp4(conn, args, text, command, fkontak, m)
break   
case 'music': case 'spotify':
spoti(conn, text, m, from) 
break
case 'gitclone':
git(conn, args, command, m) 
break
case 'tiktok': 
tiktok(conn, text, command, q, m) 
break     
case 'lyrics': case 'letra': 
letra(conn, text, command, fkontak, m) 
break
case 'mediafire': 
mediafire(conn, text, command, mediafireDl, m) 
break 
case 'facebook': case 'fb':
fb(conn, text, command, lolkeysapi, args, m) 
break
case 'instagram': case 'ig':
ig(conn, text, command, lolkeysapi, args, m) 
break
case 'igstalk':
ig2(conn, args, command, m) 
break
case 'apk': case 'modoapk':
apk(conn, text, m)  
break
		
case 'yaoi': {
conn.sendMessage(m.chat, {image: {url: "https://api.boxmine.xyz/api/nsfw/yaoi"}}, {quoted: m})
}		
break

case 'autolevel': case 'lvl': {	
if (!m.isGroup) return m.reply(mess.group)
if (!text) return m.reply(`usado err√≥neamente`)
if (args[0] === "on") {
global.db.data.chats[m.chat].autolevelup = true
m.reply(`activo`)
} else if (args[0] === "off") {
global.db.data.chats[m.chat].autolevelup = false
m.reply(`desactivado`)}}	
break 

case 'getcase': {
if (!isCreator) return m.reply('*üö© Comando solo para el creador.*')
const turbrek = `break`
if (!args[0]) return m.reply("*üö© Ingresa el nombre del case.*")
try {
m.reply('case ' + `'${args[0]}'` + fs.readFileSync('./kim.js').toString().split(`case '${args[0]}'`)[1].split(turbrek)[0] + turbrek)
} catch {
m.reply("*üö© Case no encontrado.*")
}
}
break;

case 'antilink': {
if (!m.isGroup) return reply(mess.group);
if (!isBotAdmins) return reply(mess.botAdmin);
if (!isGroupAdmins) return reply(mess.admin);
if (args[0].toLowerCase() === "on") {
if (db.data.chats[m.chat].antilink) return m.reply(`1`)
db.data.chats[m.chat].antilink = true
m.reply(`2`)
} else if (args[0].toLowerCase() === "off") {
if (!db.data.chats[m.chat].antilink) return m.reply(`3`)
db.data.chats[m.chat].antilink = false
m.reply(`4`)
} else {
hisoka.sendPoll(m.chat, "este es el ejemplo", [`${command.charAt(0).toUpperCase()+command.slice(1)} On`,`${command.charAt(0).toUpperCase()+command.slice(1)} Off`])
}
}
break
		
case 'welcome': {
  if (!m.isGroup) return reply(mess.group);
  if (!isBotAdmins) return reply(mess.botAdmin);
  if (!isGroupAdmins) return reply(mess.admin);
  if (args[0] === "on") {
  if (global.db.data.chats[m.chat].welcome) return reply (`‡ªíü´ê‚ÉüìÑª‚Éï‡ªãÍ¶∂Í¶πÍ´Ç‚äÅ *ùêÄùêúùê≠ùê¢ùêØùêöùêùùê® ùêöùêßùê≠ùêûùê´ùê¢ùê®ùê´ùê¶ùêûùêßùê≠ùêû.*`);  
global.db.data.chats[m.chat].welcome = true;
reply(`‡ªíü´ê‚ÉüìÑª‚Éï‡ªãÍ¶∂Í¶πÍ´Ç‚äÅ *ùêíùêû ùêöùêúùê≠ùê¢ùêØùê® ùêûùê±ùê¢ùê≠ùê®ùê¨ùêöùê¶ùêûùêßùê≠ùêû.*`);
      }
  else if (args[0] === "off") {
    if (!global.db.data.chats[m.chat].welcome) return reply (`‡ªíüçì‚ÉüìÑª‚Éï‡ªãÍ¶∂Í¶πÍ´Ç‚äÅ *ùêÉùêûùê¨ùêöùêúùê≠ùê¢ùêØùêöùêùùê® ùêöùêßùê≠ùêûùê´ùê¢ùê®ùê´ùê¶ùêûùêßùê≠ùêû.*`);
    global.db.data.chats[m.chat].welcome = false;
    reply(`‡ªíüçì‚ÉüìÑª‚Éï‡ªãÍ¶∂Í¶πÍ´Ç‚äÅ *ùêíùêû ùêùùêûùê¨ùêöùêúùê≠ùê¢ùêØùê®ÃÅ ùêûùê±ùê¢ùê≠ùê®ùê¨ùêöùê¶ùêûùêßùê≠ùêû.*`);
    }
}
break;

case 'join': case 'unete': {
if (!isCreator) return reply(mess.owner) 
if (!text) return reply ('Masukkan Link Group!') 
if (!isUrl(args[0]) && !args[0].includes('whatsapp.com')) return reply ('Link Invalid!') 
m.reply(mess.wait)
let result = args[0].split('https://chat.whatsapp.com/')[1]
await conn.groupAcceptInvite(result)
}
 break
		
case 'leave': case 'salte': {
  if (!isCreator) return reply(mess.owner) 
  reply(m.chat, `*Adios fue un gusto estar aqui hasta pronto*`);
  await conn.groupLeave(m.chat);
}
break

case 'prueba': {
if (!m.isGroup) return reply(mess.group) 
if (!isBotAdmins) return reply(mess.botAdmin) 
if (!isGroupAdmins) return reply(mess.admin)
    try{
let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
const response = await conn.groupRequestParticipantsList(m.chat)
await conn.groupRequestParticipantsUpdate(m.chat, users, 'approve')
} catch {
await conn.groupRequestParticipantsUpdate(m.chat, response, 'approve')
}
    }
break				

case 'prueba2': {
if (!m.isGroup) return reply(mess.group) 
if (!isBotAdmins) return reply(mess.botAdmin) 
if (!isGroupAdmins) return reply(mess.admin) 
const response = await conn.groupRequestParticipantsList(m.chat)
await conn.groupRequestParticipantsUpdate(m.chat, response, 'reject')
}
break			
		
case 'kick': case 'ban': case 'sacar': {
  if (!m.isGroup) return reply(mess.group);
  if (!isBotAdmins) return reply(mess.botAdmin);
  if (!isGroupAdmins) return reply(mess.admin);
  let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';
  conn.groupParticipantsUpdate(m.chat, [users], 'remove');
}
break

case 'add': case 'agregar': case 'a√±adir': {
if (!m.isGroup) return reply(mess.group) 
if (!isBotAdmins) return reply(mess.botAdmin) 
if (!isGroupAdmins) return reply(mess.admin) 
let users = m.mentionedJid[0] ? m.mentionedJid : m.quoted ? [m.quoted.sender] : [text.replace(/[^0-9]/g, '')+'@s.whatsapp.net']
await conn.groupParticipantsUpdate(m.chat, users, 'add')
}
break		

case 'promote': case 'daradmin': {
  if (!m.isGroup) return reply(mess.group);
  if (!isBotAdmins) return reply(mess.botAdmin);
  if (!isGroupAdmins) return reply(mess.admin);
  let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';
  await conn.groupParticipantsUpdate(m.chat, [users], 'promote').then((res) => conn.sendMessage(m.chat, {text: "*üçìÍô∞·∑ú‡∑ñ‡∑èùÜ∫‚ñ∏ ùêÄùêìùêÑùêçùêÇùêàùêéÃÅùêç*\n*‚ï∞‚ù•* ùêìùêûùêßùêûùê¶ùê®ùê¨ ùêÆùêß ùêßùêÆùêûùêØùê® ùêöùêùùê¶ùê¢ùêß\nli.‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶ÔΩ°‚è¶‚ú∞‚è¶.li", mentions: participants.map((a) => a.id)}, {quoted: m}),).catch((err) => reply("Error"));
}
break

case 'demote': case 'quitar': {
  if (!m.isGroup) return reply(mess.group);
  if (!isBotAdmins) return reply(mess.botAdmin);
  if (!isGroupAdmins) return reply(mess.admin);
  let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '') + '@s.whatsapp.net';
  await conn.groupParticipantsUpdate(m.chat, [users], 'demote').then((res) => reply("Respuesta")).catch((err) => reply("Error"));
}
break

case 'autoadmin': case 'tenerpoder': {
if (!m.isGroup) return reply(mess.group)
if (!isCreator) return reply(mess.owner)
reply('Ya eres admin üòé') 
await conn.groupParticipantsUpdate(m.chat, [m.sender], "promote")
}
break

case 'block': {
if (!isCreator) return reply(mess.owner) 
let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
await conn.updateBlockStatus(users, 'block').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
}
break

case 'unblock': {
if (!isCreator) return reply(mess.owner) 
let users = m.mentionedJid[0] ? m.mentionedJid[0] : m.quoted ? m.quoted.sender : text.replace(/[^0-9]/g, '')+'@s.whatsapp.net'
await conn.updateBlockStatus(users, 'unblock').then((res) => m.reply(jsonformat(res))).catch((err) => m.reply(jsonformat(err)))
}
break 
		
case 'setnameg': case 'setnombre': {
if (!m.isGroup) throw mess.group
if (!isBotAdmins) throw mess.botAdmin
if (!isGroupAdmins) throw mess.admin
if (!text) return reply ('Text ?') 
await conn.groupUpdateSubject(m.chat, text).then((res) => m.reply(mess.success)).catch((err) => m.reply(jsonformat(err)))
}
break

case 'setdesc': case 'setdescripcion': {
if (!m.isGroup) throw mess.group
if (!isBotAdmins) throw mess.botAdmin
if (!isGroupAdmins) throw mess.admin
if (!text) return reply ('Text ?')
await conn.groupUpdateDescription(m.chat, text).then((res) => m.reply(mess.success)).catch((err) => m.reply(jsonformat(err)))
}
break

case 'setppbot': {
if (!isCreator) throw mess.owner
if (!/image/.test(mime)) return reply (`Kirim/Reply Image Dengan Caption ${prefix + command}`) 
if (/webp/.test(mime)) return reply (`Kirim/Reply Image Dengan Caption ${prefix + command}`) 
let media = await conn.downloadAndSaveMediaMessage(qmsg)
await conn.updateProfilePicture(numBot2, { url: media }).catch((err) => fs.unlinkSync(media)) 
m.reply(mess.success)
}
break		

case 'setnameb': case 'setnamebot': {
if (!text) return reply(`Example : ${prefix + command} WhatsApp ‚úÖ`) 
let name = await conn.updateProfileName(text)
m.reply(`Successfully renamed bot to ${name}`)
}
break

case 'setstatus': case 'setbiobot': case 'setbio': {
if (!text) return reply(`this is a WhatsApp Bot named Novi Botz`) 
let name = await conn.updateProfileStatus(text)
m.reply(`Successfully changed bot bio status to ${name}`)
}
break
		
case 'setppgroup': case 'setppgrup': case 'setppg': {
if (!m.isGroup) throw mess.group
if (!isGroupAdmins) throw mess.admin
if (!quoted) return reply(`*‚ö†Ô∏èY la imagen?*`)
if (!/image/.test(mime)) return reply (`Kirim/Reply Image Dengan Caption ${prefix + command}`) 
if (/webp/.test(mime)) return reply (`Kirim/Reply Image Dengan Caption ${prefix + command}`) 
let media = await conn.downloadAndSaveMediaMessage(qmsg)
await conn.updateProfilePicture(m.chat, { url: media }).catch((err) => fs.unlinkSync(media))
m.reply(mess.success)
}
break
		
case 'banchat': {
  if (!m.isGroup) return reply(mess.group);
  if (!isBotAdmins) return reply(mess.botAdmin);
  if (!isGroupAdmins) return reply(mess.admin);
  if (args[0] === "on") {
    if (db.data.chats[m.chat].ban) return reply(`*Chat baneado*`);
    db.data.chats[m.chat].ban = true;
    reply(`ùöéùöúùöùùöé ùöåùöëùöäùöù ùöèùöûùöé ùöãùöäùöóùöéùöäùöçùöò ùöåùöòùöó ùöéùö°ùöíùöùùöò`);
  } else if (args[0] === "off") {
    if (!db.data.chats[m.chat].ban) return reply(`*Chat desbaneado*`);
    db.data.chats[m.chat].ban = false;
    reply(`ùöéùöúùöùùöé ùöåùöëùöäùöù ùöèùöûùöé ùöçùöéùöúùöãùöäùöóùöéùöäùöçùöò ùöåùöòùöó ùöéùö°ùöíùöùùöò`);
  }
}
break

case 'grupo': case 'grup': {
if (!m.isGroup) throw reply(mess.group) 
if (!isBotAdmins) throw reply(mess.botAdmin) 
if (!isGroupAdmins) return reply(mess.admin);
if (args[0].toLowerCase() === 'close'){
await conn.groupSettingUpdate(m.chat, 'announcement').then((res) => m.reply(`cerrado`)).catch((err) => m.reply(jsonformat(err)))
} else if (args[0].toLowerCase() === 'open'){
await conn.groupSettingUpdate(m.chat, 'not_announcement').then((res) => m.reply(`abierto`)).catch((err) => m.reply(jsonformat(err)))
} 
}
break

case 'editinfo': case 'editarinfo': {
if (!m.isGroup) throw reply(mess.group) 
if (!isBotAdmins) throw reply(mess.botAdmin) 
if (!isGroupAdmins) return reply(mess.admin);
if (args[0].toLowerCase() === 'open'){
await conn.groupSettingUpdate(m.chat, 'unlocked').then((res) => m.reply(`Si`)).catch((err) => m.reply(jsonformat(err)))
} else if (args[0].toLowerCase() === 'close'){
await conn.groupSettingUpdate(m.chat, 'locked').then((res) => m.reply(`No`)).catch((err) => m.reply(jsonformat(err)))
} 
}
break
		
case 'linkgroup': case 'linkgc': {
if (!m.isGroup) return reply (mess.group) 
if (!isBotAdmins) return reply (mess.botAdmin) 
let response = await conn.groupInviteCode(m.chat)
conn.sendText(m.chat, `https://chat.whatsapp.com/${response}\n\nLink Group : ${groupMetadata.subject}`, m, { detectLink: true })
}
break		

case 'blackpink':
case 'bloodfrosted':
case 'neon':
case 'minion':
case 'toxic':
case 'cloud':
case 'avenger':
case 'space':
  if (!text) { m.reply('test') }
  lol = `https://api.lolhuman.xyz/api/textprome/${command}?apikey=${lolkeysapi}&text=${text}`
  sendImageAsUrl(lol, `aqui esta su texto en estilo ${command}`)
  break

case 'hidetag':
  if (!m.isGroup) return reply(mess.group);
  if (isGroupAdmins || isCreator) {
    conn.sendMessage(m.chat,{ text: q ? q : "", mentions: participants.map((a) => a.id) },{ quoted: isGroupAdmins ? null : m });
  }
  break;

case 'tagall': case 'invocar': {
  if (!m.isGroup) return reply(mess.group);
  //if (!isBotAdmins) return reply(mess.botAdmin);
  //if (!isGroupAdmins) return reply(mess.admin);
  let teks = `‚úø ‚îÅ„Äî *üç¨ ùêàùêçùêïùêéùêÇùêÄùêÇùêàùêéÃÅùêç ùêåùêÄùêíùêàùêïùêÄ  üç¨* „Äï‚îÅ ‚úø\n\n`
  teks += `‚úø ùêíùêî ùêÄùêÉùêåùêàùêç ùêãùêéùêí ùêàùêçùêïùêéùêÇùêÄ, ùêëùêÑùêïùêàùêïùêÄùêç\n\n`
  teks += `‚úø ùêåùêÑùêçùêíùêÄùêâùêÑ: ${q ? q : 'no message'}\n\n`
  for (let mem of participants) {
  teks += `‚îÉ @${mem.id.split('@')[0]}\n‚Å©`
  }
  teks += `‚îÉ\n`
  teks += `‚îÉ‚òõùêäùê¢ùê¶ùêùùêöùêßùêÅùê®ùê≠-ùôàùòø : ùêäùê¢ùê¶ ùêÉùêöùêß\n`
  teks += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ[ *‚ú∞ ùêîùê∞ùêî ‚ú∞* ]‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚¨£`
  conn.sendMessage(m.chat, { text: teks, mentions: participants.map(a => a.id) }, { quoted: m })
}
break
		
case 'totag': {
if (!m.isGroup) return reply (mess.group) 
if (!isBotAdmins) return reply (mess.botAdmin) 
if (!isGroupAdmins) return reply (mess.admin) 
if (!m.quoted) return reply(`Reply pesan dengan caption ${prefix + command}`) 
conn.sendMessage(m.chat, { forward: m.quoted.fakeObj, mentions: participants.map(a => a.id) })
}
break
	
	case 'verificar':
let verify
if (text == 1) { 
verify = 'Ya esta regido'.trim()
} else {
verify = `üå∫‚óå‚ëÖ‚Éù‚óè‚ô°‚ãÜ‚ô° *ùêï ùêÑ ùêë ùêà ùêÖ ùêà ùêÇ ùêÄ ùêë*‚ô°‚ãÜ‚ô°‚óè‚ëÖ‚Éù‚óåüå∫

ùêëùêûùêúùêÆùêûùê´ùêùùêö ùê¢ùêßùê†ùê´ùêûùê¨ùêöùê´ ùê≠ùêÆ ùêßùê®ùê¶ùêõùê´ùêû / ùêöùê©ùê®ùêùùê® ùê≤ ùê≠ùêÆ ùêûùêùùêöùêù ùê©ùêöùê´ùêö ùê©ùê®ùêùùêûùê´ ùê´ùêûùê†ùê¢ùê¨ùê≠ùê´ùêöùê´ùê≠ùêû. 

*_ü´êùêÑ ùêâ ùêÑ ùêå ùêè ùêã ùêéü´ê_*

#verificar Kimdan.18`.trim()
}
await conn.sendMessage(m.chat, { text: verify }, { quoted: m })
break

case 'update': case `actualizar`:
if (!isCreator) return conn.sendMessage(from, { text: `*ESTE COMANDO ES PARA MI JEFE*` }, { quoted: msg });    
try {    
let stdout = execSync('git pull' + (m.fromMe && q ? ' ' + q : ''))
await conn.sendMessage(from, { text: stdout.toString() }, { quoted: msg });
} catch { 
let updatee = execSync('git remote set-url origin https://github.com/Kimdanbot-MD/KimdanBot-MD.git && git pull')
await conn.sendMessage(from, { text: updatee.toString() }, { quoted: msg })}  
break

case 'reiniciar': case 'restart': {
if (!isCreator) return conn.sendMessage(from, { text: info.owner }, { quoted: msg });   
m.reply('_üîÑ Reiniciando Bot..._');
await delay(3 * 3000) 
conn.ws.close()}
break
		
case 'pinterest':
if (!text) return reply('ùöíùöóùöêùöõùöéùöúùöä ùöûùöó ùöùùöéùö°ùöùùöò ùöôùöäùöõùöä ùöãùöûùöúùöåùöäùöõ ùöéùöó ùöôùöíùöóùöùùöéùöõùöéùöúùöù')
m.reply(mess.wait)
lol = await pinterest(text) //.catch(m.reply)
result = lol[Math.floor(Math.random() * lol.length)];
sendImageAsUrl(result, `*-------„Äå PINTEREST „Äç-------*\nü§† busqueda de ${text}\nüîó url ${result}`)
  d = Math.floor(Math.random() * 6) + 5
  global.db.data.users[m.sender].money -= d
  m.reply(`has gastado ${d} dolares`);
bbrea
		
	case 'diego':
		reply (`‚£ø‚£ø‚£ø‚†ü‚¢π‚£∂‚£∂‚£ù‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø ‚£ø‚£ø‚°ü‚¢∞‚°å‚†ø‚¢ø‚£ø‚°æ‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø ‚£ø‚£ø‚£ø‚¢∏‚£ø‚£§‚£í‚£∂‚£æ‚£≥‚°ª‚£ø‚£ø‚£ø‚£ø‚°ø‚¢õ‚£Ø‚£≠‚£≠‚£≠‚£Ω‚£ª‚£ø‚£ø‚£ø ‚£ø‚£ø‚£ø‚¢∏‚£ø‚£ø‚£ø‚£ø‚¢ø‚°á‚£∂‚°Ω‚£ø‚†ü‚£°‚£∂‚£æ‚£Ø‚£≠‚£Ω‚£ü‚°ª‚£ø‚£∑‚°Ω‚£ø ‚£ø‚£ø‚£ø‚†∏‚£ø‚£ø‚£ø‚£ø‚¢á‚†É‚£ü‚£∑‚†É‚¢∏‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ω ‚£ø‚£ø‚£ø‚£á‚¢ª‚£ø‚£ø‚£Ø‚£ï‚†ß‚¢ø‚¢ø‚£á‚¢Ø‚£ù‚£í‚£õ‚£Ø‚£≠‚£õ‚£õ‚££‚£ø‚£ø‚£ø‚°á ‚£ø‚£ø‚£ø‚£ø‚£å‚¢ø‚£ø‚£ø‚£ø‚£ø‚°ò‚£û‚£ø‚£º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á ‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚†ª‚†ø‚£ø‚£ø‚£∑‚†à‚¢û‚°á‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ó‚†Ñ‚¢ø‚£ø‚£ø‚°Ü‚°à‚£Ω‚¢∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢ª ‚£ø‚£ø‚£ø‚£ø‚°ø‚£ª‚£Ω‚£ø‚£Ü‚†π‚£ø‚°á‚†Å‚£ø‚°º‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ü‚£æ ‚£ø‚†ø‚£õ‚£Ω‚£æ‚£ø‚£ø‚†ø‚†ã‚†Ñ‚¢ª‚£∑‚£æ‚£ø‚£ß‚†ü‚£°‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°á‚£ø ‚¢º‚°ü‚¢ø‚£ø‚°ø‚†ã‚†Å‚£Ä‚°Ä‚†Ñ‚†ò‚†ä‚£®‚£Ω‚†Å‚†∞‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ç‚†ó‚£ø ‚°º‚£ø‚†Ñ‚†Ñ‚†Ñ‚†Ñ‚£º‚£ø‚°ó‚¢†‚£∂‚£ø‚£ø‚°á‚†Ñ‚†Ñ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£á‚¢†‚£ø ‚£∑‚£ù‚†Ñ‚†Ñ‚¢Ä‚†Ñ‚¢ª‚°ü‚†Ñ‚£ø‚£ø‚£ø‚£ø‚†É‚†Ñ‚†Ñ‚¢π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚¢π‚£ø ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚£Ñ‚£Å‚°Ä‚†ô‚¢ø‚°ø‚†ã‚†Ñ‚£∏‚°Ü‚†Ñ‚†ª‚£ø‚°ø‚†ü‚¢õ‚£©‚£ù‚£ö‚£ø ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£§‚£§‚£§‚£æ‚£ø‚£ø‚£Ñ‚†Ñ‚†Ñ‚†Ñ‚£¥‚£ø‚£ø‚£ø‚£á‚£ø ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£Ñ‚°Ä‚†õ‚†ø‚£ø‚£´‚£æ‚£ø`) 
  break 
	case 'mario':
		reply (`üü•üü•üü•‚¨ú‚¨úüü•üü•üü•
üü•üü•üü•‚¨ú‚¨úüü•üü•üü•
üü•üü•üü•üü•üü•üü•üü•üü•
üèª‚¨úüü¶üèªüèªüü¶‚¨úüèª
üèª‚¨úüü¶üèªüèªüü¶‚¨úüèª
üü´üèªüèªüèªüèªüèªüèªüü´
üü´üü´üèªüèªüèªüèªüü´üü´
üèª‚¨õ‚¨õ‚¨õ‚¨õ‚¨õ‚¨õüèª`) 
		break 

case 'ig': {
if (!q) return reply(`Example ${prefix+command} unicorn_xeon`)
wait() 
const aj = await igstalk(`${q}`)
conn.sendMensage(m.chat, { image: { url : aj.profile }, caption: 
`*/ Instagram Stalker \\*

Full name : ${aj.fullname}
Username : ${aj.username}
Post : ${aj.post}
Followers : ${aj.followers}
Following : ${aj.following}
Bio : ${aj.bio}` }, { quoted: m } )
}
break
	
case 'fake':
    var gh = body.slice(11);
    var mentioned = m.message.extendedTextMessage && m.message.extendedTextMessage.contextInfo && m.message.extendedTextMessage.contextInfo.mentionedJid ? m.message.extendedTextMessage.contextInfo.mentionedJid[0] : null;
    var replace = gh.split("-")[0];
    var target = gh.split("-")[1];
    var bot = gh.split("-")[2];

    if (mentioned && target && bot) {
      var quotedMessage = {
        key: {
          fromMe: false,
          participant: mentioned
        },
        message: {
          conversation: target
        }
      };

      var sendMessageOptions = {
        text: `${bot}`,
        quoted: quotedMessage
      };

      conn.sendMessage(from, sendMessageOptions, { quoted: quotedMessage });
    } else {
      conn.sendMessage(from, { text: `‚ùñ‚Éü›äüçí‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
„Äêüå∫„ÄëùêÑùê£ùêûùê¶ùê©ùê•ùê®: ${prefix + command} @tag-ùêèùêÆùê≠ùê®-ü•µ
‚ùñ‚Éü›äü´ê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`});
    }
    break
		
        default:
            if (budy.startsWith('>')) {
                if (!isCreator) return
                try {
                    return reply(JSON.stringify(eval(budy.slice(2)), null, '\t'))
                } catch (e) {
                    e = String(e)
                    reply(e)
                }
            }
            if (budy.startsWith('=>')) {
                if (!isCreator) return
                try {
                    return  reply(JSON.stringify(eval(`(async () => { ${budy.slice(3)} })()`), null, '\t')) 
                } catch (e) {
                    e = String(e)
                    reply(e)
                }
            }
            if (budy.startsWith('$')) {
                if (!isCreator) return
                try {
                    return reply(String(execSync(budy.slice(2), { encoding: 'utf-8' })))
                } catch (e) {
                    e = String(e)
                    reply(e)
                }
            }
        }

}

let file = require.resolve(__filename)
fs.watchFile(file, () => {
fs.unwatchFile(file)
console.log(chalk.redBright(`Update ${__filename}`))
delete require.cache[file]
require(file)
})
